This is a common patch to libdb48, which changes the name
of a macro to not conflict with a c++ library symbol.

In reviewing the patch on the internet, it is repeated
that bitcoin should upgrade their database recommendation
from this very, very old unmaintained version.  Concerns
are likely listed on the bitcoin issues pages.

diff -ur a/dbinc/atomic.h b/dbinc/atomic.h
--- a/dbinc/atomic.h	2010-04-12 20:25:22.000000000 +0000
+++ b/dbinc/atomic.h	2020-12-02 19:18:38.477721535 +0000
@@ -70,7 +70,7 @@
  * These have no memory barriers; the caller must include them when necessary.
  */
 #define	atomic_read(p)		((p)->value)
-#define	atomic_init(p, val)	((p)->value = (val))
+#define	atomic_init_db(p, val)	((p)->value = (val))
 
 #ifdef HAVE_ATOMIC_SUPPORT
 
@@ -206,7 +206,7 @@
 #define	atomic_dec(env, p)	(--(p)->value)
 #define	atomic_compare_exchange(env, p, oldval, newval)		\
 	(DB_ASSERT(env, atomic_read(p) == (oldval)),		\
-	atomic_init(p, (newval)), 1)
+	atomic_init_db(p, (newval)), 1)
 #else
 #define atomic_inc(env, p)	__atomic_inc(env, p)
 #define atomic_dec(env, p)	__atomic_dec(env, p)
diff -ur a/mp/mp_fget.c b/mp/mp_fget.c
--- a/mp/mp_fget.c	2010-04-12 20:25:34.000000000 +0000
+++ b/mp/mp_fget.c	2020-12-02 19:17:25.694276800 +0000
@@ -617,7 +617,7 @@
 
 		/* Initialize enough so we can call __memp_bhfree. */
 		alloc_bhp->flags = 0;
-		atomic_init(&alloc_bhp->ref, 1);
+		atomic_init_db(&alloc_bhp->ref, 1);
 #ifdef DIAGNOSTIC
 		if ((uintptr_t)alloc_bhp->buf & (sizeof(size_t) - 1)) {
 			__db_errx(env,
@@ -911,7 +911,7 @@
 			MVCC_MPROTECT(bhp->buf, mfp->stat.st_pagesize,
 			    PROT_READ);
 
-		atomic_init(&alloc_bhp->ref, 1);
+		atomic_init_db(&alloc_bhp->ref, 1);
 		MUTEX_LOCK(env, alloc_bhp->mtx_buf);
 		alloc_bhp->priority = bhp->priority;
 		alloc_bhp->pgno = bhp->pgno;
diff -ur a/mp/mp_mvcc.c b/mp/mp_mvcc.c
--- a/mp/mp_mvcc.c	2010-04-12 20:25:34.000000000 +0000
+++ b/mp/mp_mvcc.c	2020-12-02 19:18:00.595490061 +0000
@@ -276,7 +276,7 @@
 #else
 	memcpy(frozen_bhp, bhp, SSZA(BH, buf));
 #endif
-	atomic_init(&frozen_bhp->ref, 0);
+	atomic_init_db(&frozen_bhp->ref, 0);
 	if (mutex != MUTEX_INVALID)
 		frozen_bhp->mtx_buf = mutex;
 	else if ((ret = __mutex_alloc(env, MTX_MPOOL_BH,
@@ -428,7 +428,7 @@
 #endif
 		alloc_bhp->mtx_buf = mutex;
 		MUTEX_LOCK(env, alloc_bhp->mtx_buf);
-		atomic_init(&alloc_bhp->ref, 1);
+		atomic_init_db(&alloc_bhp->ref, 1);
 		F_CLR(alloc_bhp, BH_FROZEN);
 	}
 
diff -ur a/mp/mp_region.c b/mp/mp_region.c
--- a/mp/mp_region.c	2010-04-12 20:25:34.000000000 +0000
+++ b/mp/mp_region.c	2020-12-02 19:17:44.690392874 +0000
@@ -224,7 +224,7 @@
 			     MTX_MPOOL_FILE_BUCKET, 0, &htab[i].mtx_hash)) != 0)
 				return (ret);
 			SH_TAILQ_INIT(&htab[i].hash_bucket);
-			atomic_init(&htab[i].hash_page_dirty, 0);
+			atomic_init_db(&htab[i].hash_page_dirty, 0);
 		}
 
 		/*
@@ -269,7 +269,7 @@
 		hp->mtx_hash = (mtx_base == MUTEX_INVALID) ? MUTEX_INVALID :
 		    mtx_base + i;
 		SH_TAILQ_INIT(&hp->hash_bucket);
-		atomic_init(&hp->hash_page_dirty, 0);
+		atomic_init_db(&hp->hash_page_dirty, 0);
 #ifdef HAVE_STATISTICS
 		hp->hash_io_wait = 0;
 		hp->hash_frozen = hp->hash_thawed = hp->hash_frozen_freed = 0;
diff -ur a/mutex/mut_method.c b/mutex/mut_method.c
--- a/mutex/mut_method.c	2010-04-12 20:25:34.000000000 +0000
+++ b/mutex/mut_method.c	2020-12-02 19:16:47.832045447 +0000
@@ -426,7 +426,7 @@
 	MUTEX_LOCK(env, mtx);
 	ret = atomic_read(v) == oldval;
 	if (ret)
-		atomic_init(v, newval);
+		atomic_init_db(v, newval);
 	MUTEX_UNLOCK(env, mtx);
 
 	return (ret);
diff -ur a/mutex/mut_tas.c b/mutex/mut_tas.c
--- a/mutex/mut_tas.c	2010-04-12 20:25:34.000000000 +0000
+++ b/mutex/mut_tas.c	2020-12-02 19:17:07.626166398 +0000
@@ -46,7 +46,7 @@
 
 #ifdef HAVE_SHARED_LATCHES
 	if (F_ISSET(mutexp, DB_MUTEX_SHARED))
-		atomic_init(&mutexp->sharecount, 0);
+		atomic_init_db(&mutexp->sharecount, 0);
 	else
 #endif
 	if (MUTEX_INIT(&mutexp->tas)) {
@@ -486,7 +486,7 @@
 			F_CLR(mutexp, DB_MUTEX_LOCKED);
 			/* Flush flag update before zeroing count */
 			MEMBAR_EXIT();
-			atomic_init(&mutexp->sharecount, 0);
+			atomic_init_db(&mutexp->sharecount, 0);
 		} else {
 			DB_ASSERT(env, sharecount > 0);
 			MEMBAR_EXIT();
